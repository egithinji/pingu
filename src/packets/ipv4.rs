use crate::parsers::ipv4_parser::parse_ipv4;
use crate::senders::{Packet};

const FLAGSANDOFFSET: u16 = 16384_u16;
const HEADER_LENGTH: u16 = 20;

pub struct Ipv4 {
    pub version: u16,
    pub ihl: u16,
    pub type_of_service: u8,
    pub total_length: u16,
    pub identification: u16,
    pub flags: u8,
    pub fragment_offset: u16,
    pub ttl: u8,
    pub protocol: u8,
    pub header_checksum: u16,
    pub source_address: [u8; 4],
    pub dest_address: [u8; 4],
    pub payload: Vec<u8>,
    pub raw_ip_header_bytes: Vec<u8>,
    pub entire_packet: Vec<u8>,
}

impl Ipv4 {
    pub fn new(source: [u8; 4], dest: [u8; 4], protocol: u8, payload: Vec<u8>) -> Self {
        let mut temp = Ipv4 {
            version: 4,
            ihl: 5,
            type_of_service: 0,
            total_length: HEADER_LENGTH + payload.len() as u16,
            identification: 0,
            flags: 0,
            fragment_offset: 0,
            ttl: 64,
            protocol,
            header_checksum: 0,
            source_address: source,
            dest_address: dest,
            payload,
            raw_ip_header_bytes: Vec::new(),
            entire_packet: Vec::new(),
        };

        temp = Ipv4::set_raw_ip_header_bytes(temp);
        temp.header_checksum = calculate_checksum(&mut temp.raw_ip_header_bytes);
        temp = Ipv4::set_raw_ip_header_bytes(temp);
        temp.entire_packet
            .extend_from_slice(&temp.raw_ip_header_bytes);
        temp.entire_packet.extend_from_slice(&temp.payload);

        temp
    }

    fn set_raw_ip_header_bytes(mut ipv4: Ipv4) -> Ipv4 {
        let mut v: Vec<u8> = Vec::new();

        //version and ihl take up 4 bits each, so combine into one octet
        let shifted_version = ipv4.version << 4;
        let word = (shifted_version + ipv4.ihl) as u8;
        v.extend_from_slice(&word.to_be_bytes());

        //type of service
        v.extend_from_slice(&ipv4.type_of_service.to_be_bytes());

        //total length
        v.extend_from_slice(&ipv4.total_length.to_be_bytes());

        //identification
        v.extend_from_slice(&ipv4.identification.to_be_bytes());

        //flags and fragment offset:
        //The flag is the first 3 bits which should be 010 signifying "Don't Fragment" and "Last
        //Fragment".
        //The fragment offset is the next 13 bits which should be all 0s. This is equivalent to
        //0bFLAGSANDOFFSET
        v.extend_from_slice(&FLAGSANDOFFSET.to_be_bytes());

        //ttl
        v.extend_from_slice(&ipv4.ttl.to_be_bytes());

        //protocol
        v.extend_from_slice(&ipv4.protocol.to_be_bytes());

        //header checksum
        v.extend_from_slice(&ipv4.header_checksum.to_be_bytes());

        //source address
        v.extend_from_slice(&ipv4.source_address);

        //destination address
        v.extend_from_slice(&ipv4.dest_address);

        ipv4.raw_ip_header_bytes = v;

        ipv4
    }
}

fn calculate_checksum(bytes: &mut Vec<u8>) -> u16 {
    //split bytes into 16 bit chunks
    if bytes.len() % 2 != 0 {
        bytes.push(0_u8)
    }; //if odd number of bytes, add one more byte of 0
       //as padding

    let transform_to_u16 = |slice: &[u8]| {
        let a: u16 = slice[0] as u16;
        let new: u16 = a << 8;
        new + slice[1] as u16
    };

    let words: Vec<u16> = bytes.chunks(2).into_iter().map(transform_to_u16).collect();

    let mut sum: u16 = 0;

    for word in words {
        let (s, overflows) = sum.overflowing_add(word);
        sum = if overflows {
            let (result, _) = sum.carrying_add(word, true);
            result
        } else {
            s
        };
    }

    !sum
}

impl Packet for Ipv4 {
    fn raw_bytes(&self) -> &Vec<u8> {
        &self.entire_packet
    }

    fn dest_address(&self) -> Option<Vec<u8>> {
        Some(self.dest_address.to_vec())
    }

    fn source_address(&self) -> Option<Vec<u8>> {
        Some(self.source_address.to_vec())
    }
}

impl<'a> TryFrom<&'a [u8]> for Ipv4 {
    type Error = nom::Err<nom::error::Error<&'a [u8]>>;

    fn try_from(bytes: &'a [u8]) -> Result<Self, Self::Error> {
        let (_, ipv4_packet) = parse_ipv4(bytes)?;
        Ok(ipv4_packet)
    }
}

#[cfg(test)]
mod tests {
    use super::{calculate_checksum, Ipv4};
    use crate::senders::{Packet};

    #[test]
    fn raw_ip_bytes_works() {
        //The ref_bytes reference test data is the IP Header byte sequence generated by Ping in Linux when
        //pinging 8.8.8.8.
        //The following bytes will be skipped while testing:
        //  -> Total Length and Identification
        //  -> Checksum

        let ref_bytes: [u8; 20] = [
            0x45, 0x00, 0x00, 0x54, 0x3f, 0x4f, 0x40, 0x00, 0x40, 0x01, 0xc6, 0x91, 0xc0, 0xa8,
            0x64, 0x10, 0x08, 0x08, 0x08, 0x08,
        ];

        let ipv4_packet = Ipv4::new(
            [192, 168, 100, 16],
            [8, 8, 8, 8],
            1,
            Vec::new(),
        );

        assert_eq!(ref_bytes[0..2], ipv4_packet.raw_ip_header_bytes[0..2]);
        //skip Total Length and Identification
        assert_eq!(ref_bytes[6..10], ipv4_packet.raw_ip_header_bytes[6..10]);
        //skip Checksum
        assert_eq!(ref_bytes[12..], ipv4_packet.raw_ip_header_bytes[12..]);
    }
    
}
