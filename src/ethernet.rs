use crc32fast;

pub struct EthernetFrame {
    dest_mac: [u8; 6],
    source_mac: [u8; 6],
    ether_type: [u8; 2],
    payload: Vec<u8>,
    fcs: [u8; 4],
    pub raw_bytes: Vec<u8>,
}

impl EthernetFrame {
    pub fn new(ether_type: [u8;2], payload: Vec<u8>, dest_mac: [u8; 6], source_mac: [u8; 6]) -> Self {
        /*if payload.len() < 46 {
            unimplemented!();
        }*/

        let mut temp = EthernetFrame {
            dest_mac,
            source_mac,
            ether_type,
            payload,
            fcs: [0, 0, 0, 0],
            raw_bytes: Vec::new(),
        };

        EthernetFrame::set_raw_bytes(&mut temp);
        temp.fcs = get_fcs(&temp.raw_bytes);
        EthernetFrame::set_raw_bytes(&mut temp);

        temp
    }

    fn set_raw_bytes(ether: &mut EthernetFrame) {
        let mut v: Vec<u8> = Vec::new();
        v.extend_from_slice(&ether.dest_mac);
        v.extend_from_slice(&ether.source_mac);
        v.extend_from_slice(&ether.ether_type);
        v.extend_from_slice(&ether.payload);
        v.extend_from_slice(&ether.fcs);

        ether.raw_bytes = v;
    }
}

fn get_fcs(bytes: &Vec<u8>) -> [u8; 4] {
    crc32fast::hash(&bytes[0..bytes.len() - 4]).to_le_bytes() //had to reverse endianness for it to
                                                              //work.
}

mod tests {
   
    use crate::packets;
    use super::EthernetFrame;
    const DEST_MAC: [u8;6] = [0xe0,0xcc,0x7a,0x34,0x3f,0xa3];
    const SOURCE_MAC: [u8;6] = [0x04,0x92,0x26,0x19,0x4e,0x4f];

    #[test]
    fn valid_ethernet_frame_created() {

        //The ref_bytes reference test data is an ethernet byte sequence generated by Ping in Linux when
        //pinging 8.8.8.8.
        //The following bytes will be skipped while testing:
        //  -> IP Header Total Length and Identification
        //  -> IP Header Checksum
        //  -> ICMP Checksum, Identifier, Sequence Number, and Timestamp 

        let ref_bytes: [u8; 98] = [
            0xe0, 0xcc, 0x7a, 0x34, 0x3f, 0xa3, 0x04, 0x92, 0x26, 0x19, 0x4e, 0x4f, 0x08, 0x00,
            0x45, 0x00, 0x00, 0x54, 0x3f, 0x4f, 0x40, 0x00, 0x40, 0x01, 0xc6, 0x91, 0xc0, 0xa8,
            0x64, 0x10, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x0c, 0x17, 0x72, 0xe8, 0x00, 0x01,
            0x08, 0x9b, 0x8b, 0x62, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x2f, 0x0b, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
            0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
            0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        ];

        let icmp_packet = packets::IcmpRequest::new([192, 168, 100, 16], [8, 8, 8, 8]);
        let eth_packet = EthernetFrame::new([0x08,0x00],icmp_packet.entire_packet,DEST_MAC,SOURCE_MAC);

        assert_eq!(&ref_bytes[0..16],&eth_packet.raw_bytes[0..16]); 
        //Skip IP Header Total Length and Identification 
        assert_eq!(&ref_bytes[20..24],&eth_packet.raw_bytes[20..24]); 
        //Skip IP Header Checksum
        assert_eq!(&ref_bytes[26..36],&eth_packet.raw_bytes[26..36]);                                                           
        //Skip ICMP Checksum, Identifier, Sequence Number, and Timestamp
        //Note that timestamp is present in ref_bytes but not in eth_packet.raw_bytes (currently).
        assert_eq!(&ref_bytes[50..98],&eth_packet.raw_bytes[42..90]);                                                           
    }
}
