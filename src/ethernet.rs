use crc32fast;

pub struct EthernetFrame<'a> {
    pub dest_mac: &'a [u8],
    pub source_mac: &'a [u8],
    pub ether_type: &'a [u8],
    pub payload: &'a [u8],
    pub fcs: [u8; 4],
    pub raw_bytes: Vec<u8>,
}

impl<'a> EthernetFrame<'a> {
    pub fn new(
        ether_type: &'a [u8],
        payload: &'a [u8],
        dest_mac: &'a [u8],
        source_mac: &'a [u8],
    ) -> Self {
        /*
        if ether_type.len() != 2 {
            todo!();
        }
        if payload.len() < 46 {
            todo!();
        }
        if dest_mac.len() != 6 {
            todo!();
        }
        if source_mac.len() != 6 {
            todo!();
        }*/

        let mut temp = EthernetFrame {
            dest_mac,
            source_mac,
            ether_type,
            payload,
            fcs: [0, 0, 0, 0],
            raw_bytes: Vec::new(),
        };

        EthernetFrame::set_raw_bytes(&mut temp);
        temp.fcs = get_fcs(&temp.raw_bytes);
        EthernetFrame::set_raw_bytes(&mut temp);

        temp
    }

    fn set_raw_bytes(ether: &mut EthernetFrame) {
        let mut v: Vec<u8> = Vec::new();
        v.extend_from_slice(ether.dest_mac);
        v.extend_from_slice(ether.source_mac);
        v.extend_from_slice(ether.ether_type);
        v.extend_from_slice(ether.payload);
        v.extend_from_slice(&ether.fcs);

        ether.raw_bytes = v;
    }
}

fn get_fcs(bytes: &Vec<u8>) -> [u8; 4] {
    crc32fast::hash(&bytes[0..bytes.len() - 4]).to_le_bytes() //had to reverse endianness for it to
                                                              //work.
}

impl<'a> TryFrom<&'a [u8]> for EthernetFrame<'a> {
    type Error = &'static str;

    fn try_from(bytes: &'a [u8]) -> Result<Self, Self::Error> {
        //use the eth_type (bytes of index 12 and 13) as a validity check
        match bytes[12..14] {
            [0x08, 0x00] | [0x08, 0x06] => Ok(EthernetFrame::new(
                &bytes[12..14],
                &bytes[14..],
                &bytes[0..6],
                &bytes[6..12],
            )),
            _ => {
                println!("eth_type: {:?}", &bytes[12..14]);
                Err("Ethernet packet not recognized.")},
        }
    }
}

mod tests {

    use super::EthernetFrame;
    use crate::icmp;
    use crate::ipv4::Ipv4;
    use crate::senders::{Packet, PacketType};
    const DEST_MAC: [u8; 6] = [0xe0, 0xcc, 0x7a, 0x34, 0x3f, 0xa3];
    const SOURCE_MAC: [u8; 6] = [0x04, 0x92, 0x26, 0x19, 0x4e, 0x4f];

    #[test]
    fn valid_ethernet_frame_created() {
        //The ref_bytes reference test data is an ethernet byte sequence generated by Ping in Linux when
        //pinging 8.8.8.8.
        //The following bytes will be skipped while testing:
        //  -> IP Header Total Length and Identification
        //  -> IP Header Checksum
        //  -> ICMP Checksum, Identifier, Sequence Number, and Timestamp

        let ref_bytes: [u8; 98] = [
            0xe0, 0xcc, 0x7a, 0x34, 0x3f, 0xa3, 0x04, 0x92, 0x26, 0x19, 0x4e, 0x4f, 0x08, 0x00,
            0x45, 0x00, 0x00, 0x54, 0x3f, 0x4f, 0x40, 0x00, 0x40, 0x01, 0xc6, 0x91, 0xc0, 0xa8,
            0x64, 0x10, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x0c, 0x17, 0x72, 0xe8, 0x00, 0x01,
            0x08, 0x9b, 0x8b, 0x62, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x2f, 0x0b, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
            0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
            0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        ];

        let icmp_packet = icmp::IcmpRequest::new();
        let ipv4_packet = Ipv4::new([192, 168, 100, 16], [8, 8, 8, 8], icmp_packet.raw_bytes().clone(), PacketType::IcmpRequest); 
        let eth_packet = EthernetFrame::new(
            &[0x08, 0x00],
            &ipv4_packet.entire_packet,
            &DEST_MAC,
            &SOURCE_MAC,
        );

        assert_eq!(&ref_bytes[0..16], &eth_packet.raw_bytes[0..16]);
        //Skip IP Header Total Length and Identification
        assert_eq!(&ref_bytes[20..24], &eth_packet.raw_bytes[20..24]);
        //Skip IP Header Checksum
        assert_eq!(&ref_bytes[26..36], &eth_packet.raw_bytes[26..36]);
        //Skip ICMP Checksum, Identifier, Sequence Number, and Timestamp
        //Note that timestamp is present in ref_bytes but not in eth_packet.raw_bytes (currently).
        assert_eq!(&ref_bytes[50..98], &eth_packet.raw_bytes[42..90]);
    }

    #[test]
    fn valid_ethernetframe_created_from_bytes() {
        //received_bytes are taken contents of icmp reply received from 8.8.8.8 after pinging from Linux.
        let received_bytes = &[
            0x04, 0x92, 0x26, 0x19, 0x4e, 0x4f, 0xe0, 0xcc, 0x7a, 0x34, 0x3f, 0xa3, 0x08, 0x00,
            0x45, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x01, 0x4a, 0xe1, 0x08, 0x08,
            0x08, 0x08, 0xc0, 0xa8, 0x64, 0x10, 0x00, 0x00, 0x28, 0xe3, 0x48, 0xc6, 0x00, 0x01,
            0x9d, 0x43, 0x8e, 0x62, 0x00, 0x00, 0x00, 0x00, 0x96, 0xdc, 0x0d, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
            0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
            0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        ]
        .to_vec()[..];

        let expected = EthernetFrame {
            dest_mac: &[0x04, 0x92, 0x26, 0x19, 0x4e, 0x4f],
            source_mac: &[0xe0, 0xcc, 0x7a, 0x34, 0x3f, 0xa3],
            ether_type: &[0x08, 0x00],
            payload: &vec![0; 84], //Not interested in contents of payload but the length should be correct
            fcs: [0, 0, 0, 0],
            raw_bytes: vec![0; 98],
        };

        let test_eth_frame = EthernetFrame::try_from(received_bytes).unwrap();

        assert_eq!(test_eth_frame.dest_mac, expected.dest_mac);
        assert_eq!(test_eth_frame.source_mac, expected.source_mac);
        assert_eq!(test_eth_frame.ether_type, expected.ether_type);
        assert_eq!(test_eth_frame.payload.len(), expected.payload.len());
        assert_eq!(test_eth_frame.raw_bytes.len()-4, received_bytes.len()); //-4 becase of fcs
    }
}
