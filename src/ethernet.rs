use crate::senders::{Packet,PacketType};
use crc32fast;

pub struct EthernetFrame<'a> {
    pub dest_mac: &'a [u8],
    pub source_mac: &'a [u8],
    pub ether_type: &'a [u8],
    pub payload: &'a [u8],
    pub fcs: [u8; 4],
    pub raw_bytes: Vec<u8>,
}

impl<'a> EthernetFrame<'a> {
    pub fn new(
        ether_type: &'a [u8],
        payload: &'a [u8],
        dest_mac: &'a [u8],
        source_mac: &'a [u8],
    ) -> Self {
        /*
        if ether_type.len() != 2 {
            todo!();
        }
        if payload.len() < 46 {
            todo!();
        }
        if dest_mac.len() != 6 {
            todo!();
        }
        if source_mac.len() != 6 {
            todo!();
        }*/

        let mut temp = EthernetFrame {
            dest_mac,
            source_mac,
            ether_type,
            payload,
            fcs: [0, 0, 0, 0],
            raw_bytes: Vec::new(),
        };

        EthernetFrame::set_raw_bytes(&mut temp);
        temp.fcs = get_fcs(&temp.raw_bytes);
        EthernetFrame::set_raw_bytes(&mut temp);

        temp
    }

    fn set_raw_bytes(ether: &mut EthernetFrame) {
        let mut v: Vec<u8> = Vec::new();
        v.extend_from_slice(ether.dest_mac);
        v.extend_from_slice(ether.source_mac);
        v.extend_from_slice(ether.ether_type);
        v.extend_from_slice(ether.payload);
        v.extend_from_slice(&ether.fcs);

        ether.raw_bytes = v;
    }
}

fn get_fcs(bytes: &Vec<u8>) -> [u8; 4] {
    crc32fast::hash(&bytes[0..bytes.len() - 4]).to_le_bytes() //had to reverse endianness for it to
                                                              //work.
}

impl<'a> TryFrom<&'a [u8]> for EthernetFrame<'a> {
    type Error = &'static str;

    fn try_from(bytes: &'a [u8]) -> Result<Self, Self::Error> {
        //use the eth_type (bytes of index 12 and 13) as a validity check
        match bytes[12..14] {
            [0x08, 0x00] | [0x08, 0x06] => Ok(EthernetFrame::new(
                &bytes[12..14],
                &bytes[14..],
                &bytes[0..6],
                &bytes[6..12],
            )),
            _ => {
                println!("eth_type: {:?}", &bytes[12..14]);
                Err("Ethernet packet not recognized.")},
        }
    }
}

impl<'a> Packet for EthernetFrame<'a> {

    fn raw_bytes(&self) -> &Vec<u8> {
        &self.raw_bytes
    }

    fn packet_type(&self) -> PacketType {
        PacketType::Ethernet
    }

    fn dest_address(&self) -> Option<Vec<u8>> {
        Some(self.dest_mac.to_vec())
    }

    fn source_address(&self) -> Option<Vec<u8>> {
        Some(self.source_mac.to_vec())
    }
    
}

mod tests {

    use super::EthernetFrame;
    use crate::icmp;
    use crate::ipv4::Ipv4;
    use crate::senders::{Packet, PacketType};
    use crate::utilities::{get_wireshark_bytes, get_local_mac_ip};
    const DEST_MAC: [u8; 6] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    const SOURCE_MAC: [u8; 6] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    #[test]
    fn valid_ethernet_frame_created() {
        //The ref_bytes reference test data is an ethernet byte sequence generated by Ping in Linux when
        //pinging 8.8.8.8.
        //The following bytes will be skipped while testing:
        //  -> IP Header Total Length and Identification
        //  -> IP Header Checksum
        //  -> ICMP Checksum, Identifier, Sequence Number, and Timestamp

        let ref_bytes: [u8; 98] = get_wireshark_bytes("test_ethernet_frame_sent.txt").try_into().unwrap();
        let (source_mac,_) = get_local_mac_ip();
        let source_mac: [u8;6] = source_mac.try_into().unwrap();
        let dest_mac: [u8;6] = get_wireshark_bytes("test_default_gateway_mac.txt").try_into().unwrap();
        let icmp_packet = icmp::IcmpRequest::new();
        let ipv4_packet = Ipv4::new([192, 168, 100, 16], [8, 8, 8, 8], icmp_packet.raw_bytes().clone(), PacketType::IcmpRequest); 
        let eth_packet = EthernetFrame::new(
            &[0x08, 0x00],
            &ipv4_packet.entire_packet,
            &dest_mac,
            &source_mac,
        );

        assert_eq!(&ref_bytes[0..16], &eth_packet.raw_bytes[0..16]);
        //Skip IP Header Total Length and Identification
        assert_eq!(&ref_bytes[20..24], &eth_packet.raw_bytes[20..24]);
        //Skip IP Header Checksum
        assert_eq!(&ref_bytes[26..36], &eth_packet.raw_bytes[26..36]);
        //Skip ICMP Checksum, Identifier, Sequence Number, and Timestamp
        //Note that timestamp is present in ref_bytes but not in eth_packet.raw_bytes (currently).
        assert_eq!(&ref_bytes[50..98], &eth_packet.raw_bytes[42..90]);
    }

    #[test]
    fn valid_ethernetframe_created_from_bytes() {
        //received_bytes are taken contents of icmp reply received from 8.8.8.8 after pinging from Linux.
        let received_bytes = &get_wireshark_bytes("test_ethernet_frame_reply.txt")[..];
        let received_payload_bytes = &get_wireshark_bytes("test_ethernet_frame_reply_payload.txt");
        let (dest_mac,_) = get_local_mac_ip();
        let dest_mac: [u8;6] = dest_mac.try_into().unwrap();
        let source_mac: [u8;6] = get_wireshark_bytes("test_default_gateway_mac.txt").try_into().unwrap();
        let expected = EthernetFrame {
            dest_mac: &dest_mac,
            source_mac: &source_mac,
            ether_type: &[0x08, 0x00],
            payload: &vec![0; 84], //Not interested in contents of payload but the length should be correct
            fcs: [0, 0, 0, 0], //Not interested in comparing fcs
            raw_bytes: vec![0; 98], //Just interested in the length
        };

        let test_eth_frame = EthernetFrame::try_from(received_bytes).unwrap();

        assert_eq!(test_eth_frame.dest_mac, expected.dest_mac);
        assert_eq!(test_eth_frame.source_mac, expected.source_mac);
        assert_eq!(test_eth_frame.ether_type, expected.ether_type);
        assert_eq!(test_eth_frame.payload.len(), expected.payload.len());
        assert_eq!(test_eth_frame.raw_bytes.len()-4, received_bytes.len()); //-4 becase of fcs
    }
}
